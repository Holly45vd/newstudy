import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  Box,
  Stack,
  Typography,
  TextField,
  Button,
  Chip,
  Divider,
  Table,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
  Paper,
  TableContainer,
  IconButton,
  Tooltip,
  Alert,
  LinearProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
} from "@mui/material";
import SaveIcon from "@mui/icons-material/Save";
import RefreshIcon from "@mui/icons-material/Refresh";
import CheckCircleIcon from "@mui/icons-material/CheckCircle";
import ErrorOutlineIcon from "@mui/icons-material/ErrorOutline";
import DownloadIcon from "@mui/icons-material/Download";
import UploadFileIcon from "@mui/icons-material/UploadFile";

import { fetchUnitById, fetchWordsByIds, upsertWord } from "../../firebase/firebaseFirestore";

/* ---------------- Í∏∞Î≥∏ ÏãúÎìú (ÎàÑÎùΩ ÎåÄÎπÑ) ---------------- */
const DEFAULT_SEED = {
  Á¶ªÂà´: { pinyin: "l√≠ bi√©", ko: "Ïù¥Î≥Ñ(ÌïòÎã§)", pos: "Âä®/Âêç" },
  ‰∏ÄÂπï: { pinyin: "y√≠ m√π", ko: "(Ïó∞Í∑π) Ìïú Ïû•Î©¥", pos: "Âêç" },
  ÊÄª‰ºö: { pinyin: "z«íng hu√¨", ko: "Ïñ∏Ï††Í∞Ä ~ÌïòÍ≤å ÎêòÎã§", pos: "ÂâØ" },
  ÈáçÊºî: { pinyin: "ch√≥ng y«én", ko: "Ïû¨Ïó∞ÎêòÎã§", pos: "Âä®" },
  Âá†‰πé: { pinyin: "jƒ´ h≈´", ko: "Í±∞Ïùò", pos: "ÂâØ" },
  Êää: { pinyin: "b«é", ko: "~ÏùÑ/Î•º (Ï≤òÏπòÎ¨∏)", pos: "‰ªã" },
  ‰øùÈáç: { pinyin: "b«éo zh√≤ng", ko: "Î™∏Ï°∞Ïã¨Ìï¥Ïöî", pos: "Âä®" },
};

/* ---------------- Ïú†Ìã∏ ---------------- */
const sanitizeRow = (w) => ({
  id: String(w.id || w.zh || "").trim(),
  zh: String(w.zh || w.hanzi || w.id || "").trim(),
  pinyin: String(w.pinyin || w.py || "").trim(),
  ko: String(w.ko || w.meaning || "").trim(),
  pos: String(w.pos || "").trim(),
  tags: Array.isArray(w.tags) ? w.tags : [],
  sentence: String(w.sentence || w.exampleZh || "").trim(),
  sentencePinyin: String(w.sentencePinyin || w.examplePy || "").trim(),
  sentenceKo: String(w.sentenceKo || w.exampleKo || "").trim(),
});

/* ---------------- Î©îÏù∏ Ïª¥Ìè¨ÎÑåÌä∏ ---------------- */
export default function WordsAdminPage() {
  const [unitId, setUnitId] = useState("22");
  const [unit, setUnit] = useState(null);
  const [existing, setExisting] = useState([]);
  const [rows, setRows] = useState([]);
  const [loading, setLoading] = useState(false);
  const [msg, setMsg] = useState("");

  const [jsonOpen, setJsonOpen] = useState(false);
  const [jsonText, setJsonText] = useState("");
  const fileInputRef = useRef(null);

  /* ---------------- Î°úÎìú ---------------- */
  const load = useCallback(async () => {
    if (!unitId) return;
    setLoading(true);
    setMsg("");
    try {
      const u = await fetchUnitById(unitId);
      if (!u) throw new Error(`unit ${unitId} ÏóÜÏùå`);
      const ids = Array.isArray(u.vocabIds) ? u.vocabIds.map(String) : [];
      const words = ids.length ? await fetchWordsByIds(ids) : [];
      setUnit(u);
      setExisting(words);

      const found = new Set(words.map((w) => String(w.id)));
      const missing = ids.filter((zh) => !found.has(String(zh)));

      const seedRows = missing.map((zh) => ({
        zh,
        id: zh,
        pinyin: DEFAULT_SEED[zh]?.pinyin || "",
        ko: DEFAULT_SEED[zh]?.ko || "",
        pos: DEFAULT_SEED[zh]?.pos || "",
        tags: [],
        sentence: "",
        sentencePinyin: "",
        sentenceKo: "",
      }));

      const existingRows = words.map(sanitizeRow);
      setRows([...seedRows, ...existingRows]);

      setMsg(
        `‚úÖ Unit ${unitId} Î∂àÎü¨Ïò§Í∏∞ ÏôÑÎ£å | Îã®Ïñ¥ ${ids.length}Í∞ú Ï§ë Ï°¥Ïû¨ ${words.length}, ÎàÑÎùΩ ${missing.length}`
      );
    } catch (e) {
      setMsg(`‚ùå Î°úÎìú Ïã§Ìå®: ${e.message}`);
    } finally {
      setLoading(false);
    }
  }, [unitId]);

  useEffect(() => {
    load();
  }, [load]);

  /* ---------------- ÎàÑÎùΩ Í≥ÑÏÇ∞ ---------------- */
  const missingSet = useMemo(() => {
    const ex = new Set(existing.map((w) => String(w.id)));
    const ids = (unit?.vocabIds || []).map(String);
    return new Set(ids.filter((zh) => !ex.has(zh)));
  }, [unit, existing]);

  /* ---------------- ÏÖÄ Î≥ÄÍ≤Ω ---------------- */
  const onChangeCell = (i, key, val) => {
    setRows((prev) => prev.map((r, idx) => (idx === i ? { ...r, [key]: val } : r)));
  };

  /* ---------------- Ï†ÄÏû• ---------------- */
  const saveSelected = async (filterFn) => {
    setLoading(true);
    setMsg("");
    try {
      const targets = rows.filter(filterFn).map(sanitizeRow).filter((r) => r.zh);
      for (const w of targets) await upsertWord(w.zh, w);
      setMsg(`üíæ Ï†ÄÏû• ÏôÑÎ£å: ${targets.length}Í∞ú ÏóÖÏÑúÌä∏`);
      await load();
    } catch (e) {
      setMsg(`‚ùå Ï†ÄÏû• Ïã§Ìå®: ${e.message}`);
    } finally {
      setLoading(false);
    }
  };

  /* ---------------- JSON Ìé∏ÏßëÍ∏∞ ---------------- */
  const openJsonEditor = () => {
    setJsonText(JSON.stringify(rows, null, 2));
    setJsonOpen(true);
  };

  const applyJsonToRows = () => {
    try {
      const parsed = JSON.parse(jsonText);
      if (!Array.isArray(parsed)) throw new Error("JSON Î£®Ìä∏Îäî Î∞∞Ïó¥Ïù¥Ïñ¥Ïïº Ìï®");
      setRows(parsed.map(sanitizeRow).filter((r) => r.zh));
      setMsg("‚úÖ JSON Ï†ÅÏö© ÏôÑÎ£å");
      setJsonOpen(false);
    } catch (e) {
      setMsg(`‚ùå JSON Ïò§Î•ò: ${e.message}`);
    }
  };

  const downloadJson = () => {
    const blob = new Blob([JSON.stringify(rows, null, 2)], {
      type: "application/json;charset=utf-8",
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `words-unit-${unitId}.json`;
    a.click();
    URL.revokeObjectURL(url);
  };

  const onPickFile = (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    const r = new FileReader();
    r.onload = () => setJsonText(String(r.result || ""));
    r.readAsText(f, "utf-8");
    e.target.value = "";
  };

  /* ---------------- Î†åÎçî ---------------- */
  return (
    <Box p={2}>
      <Stack direction="row" spacing={1} alignItems="center">
        <Typography variant="h5">üìò Words Admin</Typography>
        <Box flexGrow={1} />
        <TextField
          label="Unit ID"
          size="small"
          value={unitId}
          onChange={(e) => setUnitId(e.target.value)}
          sx={{ width: 120 }}
        />
        <Button variant="outlined" startIcon={<RefreshIcon />} onClick={load}>
          Î∂àÎü¨Ïò§Í∏∞
        </Button>
      </Stack>

      {loading && <LinearProgress sx={{ my: 1 }} />}
      {msg && (
        <Alert severity="info" sx={{ my: 1 }}>
          {msg}
        </Alert>
      )}

      <Stack direction="row" spacing={1} mb={1}>
        <Chip label={`Îã®Ïñ¥Ïàò: ${unit?.vocabIds?.length || 0}`} />
        <Chip color="success" icon={<CheckCircleIcon />} label={`Ï°¥Ïû¨: ${existing.length}`} />
        <Chip color="warning" icon={<ErrorOutlineIcon />} label={`ÎàÑÎùΩ: ${missingSet.size}`} />
      </Stack>

      <Divider sx={{ my: 2 }} />

      <Stack direction="row" spacing={1} mb={1} flexWrap="wrap">
        <Button
          variant="contained"
          startIcon={<SaveIcon />}
          onClick={() => saveSelected((w) => missingSet.has(String(w.zh)))}
        >
          ÎàÑÎùΩÎßå Ï†ÄÏû•
        </Button>
        <Button variant="outlined" startIcon={<SaveIcon />} onClick={() => saveSelected(() => true)}>
          Ï†ÑÏ≤¥ Ï†ÄÏû•(ÎçÆÏñ¥Ïì∞Í∏∞)
        </Button>
        <Button variant="outlined" onClick={openJsonEditor}>
          JSON Î≥¥Í∏∞/ÏàòÏ†ï
        </Button>
      </Stack>

      <TableContainer component={Paper} sx={{ borderRadius: 2 }}>
        <Table size="small" stickyHeader>
          <TableHead>
            <TableRow>
              <TableCell>zh</TableCell>
              <TableCell>pinyin</TableCell>
              <TableCell>ko</TableCell>
              <TableCell>pos</TableCell>
              <TableCell>tags</TableCell>
              <TableCell>sentence</TableCell>
              <TableCell>sentencePinyin</TableCell>
              <TableCell>sentenceKo</TableCell>
              <TableCell>ÏÉÅÌÉú</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {rows.length === 0 && (
              <TableRow>
                <TableCell colSpan={9} align="center">
                  Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå
                </TableCell>
              </TableRow>
            )}
            {rows.map((r, i) => {
              const missing = missingSet.has(r.zh);
              return (
                <TableRow key={`${r.zh}-${i}`} hover>
                  {["zh", "pinyin", "ko", "pos", "sentence", "sentencePinyin", "sentenceKo"].map(
                    (key) => (
                      <TableCell key={key}>
                        <TextField
                          size="small"
                          value={r[key] || ""}
                          onChange={(e) => onChangeCell(i, key, e.target.value)}
                        />
                      </TableCell>
                    )
                  )}
                  <TableCell>
                    <TextField
                      size="small"
                      value={(r.tags || []).join(",")}
                      onChange={(e) =>
                        onChangeCell(
                          i,
                          "tags",
                          e.target.value.split(",").map((x) => x.trim()).filter(Boolean)
                        )
                      }
                    />
                  </TableCell>
                  <TableCell align="center">
                    <Tooltip title={missing ? "ÎØ∏Ï°¥Ïû¨" : "Ï°¥Ïû¨"}>
                      <IconButton color={missing ? "warning" : "success"} size="small">
                        {missing ? <ErrorOutlineIcon /> : <CheckCircleIcon />}
                      </IconButton>
                    </Tooltip>
                  </TableCell>
                </TableRow>
              );
            })}
          </TableBody>
        </Table>
      </TableContainer>

      {/* JSON Ìé∏Ïßë Î™®Îã¨ */}
      <Dialog open={jsonOpen} onClose={() => setJsonOpen(false)} fullWidth maxWidth="md">
        <DialogTitle>JSON Î≥¥Í∏∞/ÏàòÏ†ï</DialogTitle>
        <DialogContent dividers>
          <Stack direction="row" spacing={1} mb={1}>
            <Button size="small" startIcon={<DownloadIcon />} onClick={downloadJson}>
              Îã§Ïö¥Î°úÎìú
            </Button>
            <input
              type="file"
              accept="application/json"
              ref={fileInputRef}
              onChange={onPickFile}
              style={{ display: "none" }}
            />
            <Button size="small" startIcon={<UploadFileIcon />} onClick={() => fileInputRef.current?.click()}>
              ÌååÏùº Î∂àÎü¨Ïò§Í∏∞
            </Button>
          </Stack>
          <TextField
            fullWidth
            multiline
            minRows={18}
            value={jsonText}
            onChange={(e) => setJsonText(e.target.value)}
            placeholder='[{"zh":"Á¶ªÂà´","pinyin":"l√≠ bi√©","ko":"Ïù¥Î≥Ñ","pos":"Âä®/Âêç"}]'
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setJsonOpen(false)}>Îã´Í∏∞</Button>
          <Button variant="contained" onClick={applyJsonToRows}>
            JSON Ï†ÅÏö©
          </Button>
          <Button
            variant="outlined"
            onClick={() => {
              try {
                const parsed = JSON.parse(jsonText);
                const normalized = parsed.map(sanitizeRow).filter((r) => r.zh);
                setRows(normalized);
                setJsonOpen(false);
                setTimeout(() => saveSelected(() => true), 0);
              } catch (e) {
                setMsg(`‚ùå JSON Ïò§Î•ò: ${e.message}`);
              }
            }}
          >
            JSON ‚Üí Ï†ÄÏû•(Ï†ÑÏ≤¥ ÏóÖÏÑúÌä∏)
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
}
